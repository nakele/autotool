function initiate(context){

document = context.document;
artboards = document.artboards();
pages = document.pages();
selection = context.selection;
json = {};

ClassGroup = require('sketch/dom').Group;

//move selection of object into a group
moveSelectionToGroup = function(selection){
var list = [];
selection.forEach(function (layer, i) {
    list.push(layer);
  });
var parent = list[0].parentObject();
var newGroup = new ClassGroup({
                          name: "Group",
                          layers: list,
                          parent: parent,
                          });
for(var i in list){
parent.removeLayer(list[i]);
}
newGroup.adjustToFit();
}

//unlink a symbol instance from it's library
unlink = function(symbol){
  symbol.unlinkFromRemote();
}

//this loop through linked instances and unlink all of them
loopUnlink = function(){

var _loopUnlink = function(){

  list = [];

  for (var i = 0; i < documentData.foreignSymbols().count(); i++) {

    var foreignSymbol = documentData.foreignSymbols().objectAtIndex(i);

    list.push(foreignSymbol);
    unlink(foreignSymbol);

  }
  log(list.length)
  if(documentData.foreignSymbols().count()>0){_loopUnlink()}

}

var documentData = context.document.documentData();

var list = []

_loopUnlink();

}

breakAllSymbols = function(_list,recursively){
    if(typeof recursively == "undefined"){recursively = true}else if(typeof recursively != "boolean"){return "Second parameter needs to be true or false"};
    if(typeof _list == "undefined"){return "An array of symbols is needed"};
var sketch = require('sketch')

var document = sketch.getSelectedDocument()

var selectedLayers = _list
var selectedCount = selectedLayers.length

if (selectedCount === 0) {
  console.log('No layers found.')
} else {
  console.log('Recursively detaching '+ selectedCount + " layers");
  selectedLayers.forEach(function (layer, i) {
    if(layer.className() == "MSSymbolInstance"){
        var sketchObject = sketch.fromNative(layer)
        sketchObject.detach({recursively: recursively})
    }
  })
}
}

selectAllInstanes = function(){
var document = context.document;

var list = []

list = document.currentPage().children();

var _list = [];
for(var i = 0; i < list.length; i++){
if(list[i].className() == "MSSymbolInstance"){
_list.push(list[i]);
}
}

return _list

}

//newshape
newShape = function(x, y, w, h, r, Fx, Fy, name, R, G, B, A){
        var Rectangle = require('sketch/dom').Rectangle;
        var rect = new Rectangle(x, y, w, h);
        var cgRect = rect.asCGRect();
        var obj = MSShapeGroup.shapeWithRect(cgRect);
        obj.setName(name);
        var style = MSStyle.alloc().init();
        var color = MSColor.colorWithRed_green_blue_alpha(R, G, B, A),
        fill = style.addStylePartOfType(0);
        fill.color = color;
        obj.setStyle(style);
        obj.setRotation(r);
        obj.setIsFlippedHorizontal(Fx);
        obj.setIsFlippedVertical(Fy);
        return obj;
    }

//convert 255 code color to % base 0 - 1 range
convertColor = function(color){
    return color/255
}

addShape = function(obj1){
    var thing =  newShape(obj1.rect().origin.x,obj1.rect().origin.y,obj1.rect().size.width,obj1.rect().size.height,obj1.rotation(),obj1.isFlippedHorizontal(),obj1.isFlippedVertical(), "##shapeHighligh##", 255/255,248/255,28/255,0.3);
    obj1.parentObject().addLayers_([thing]);
}


addObjectForShapeArray = []
addObjectForShape = function(obj){
    if(addObjectForShapeArray.indexOf(obj)==-1 ){
        addObjectForShapeArray.push(obj);
    }
}

process_addObjectForShapeArray = function(){
    for (var i = addObjectForShapeArray.length - 1; i >= 0; i--) {
        addShape(addObjectForShapeArray[i])
    };
}



//set interval like javascript 
//fn is the function needed to pass
//time_ms is the time in milliseconds
setInterval = function(fn, time_ms) {
  coscript.setShouldKeepAround(true);
  var time_sec = time_ms / 1000;
  return coscript.scheduleWithRepeatingInterval_jsFunction(time_sec, fn);
}

//clear interval > setInterval returns the interval so keep track of that in order to clear it
clearInterval = function(interval) {
  coscript.setShouldKeepAround(false);
  interval.cancel();
}

//return HR + MIN + SEC so this does not work at midnight
timestamp = function(){
    var time = Date().split(" ")[4].split(":");
    return (time[0]*60+time[1])*60+time[2]
}


//make a list of all the layers from the current page
children = [];
currentChildren = document.currentPage().children();
//
for(var i=0; i<currentChildren.length; i++){
    children.push(currentChildren[i]);
}
//*/

//old version
/*/
for(var i=0; i<document.currentPage().children().length; i++){
    children.push(document.currentPage().children()[i])
}
//*/


//  #########################################################
//  ### This is an emulation of for loop that includes    ###
//  ### a message every second to inform of the progress  ###
//  #########################################################

document.showMessage("Plugin started");

now = timestamp();

fnn = function(){
    document.showMessage("In progress "+Math.round((i/document.currentPage().children().length)*100)+"%");
    clearInterval(interval);
    while_loop_fn();
}

interval = 0;

i = 0;
now = null;

while_loop_fn = function(){
while(i<document.currentPage().children().length){
    if(now==null){now=timestamp()};
    if(timestamp()-now>=1){
        now=null;
        interval = setInterval(fnn,100);
        return;
    }
    children.push(document.currentPage().children()[i]);
    i+=1;
}
if(i>=document.currentPage().children().length){
    document.showMessage("Plugin completed");
}
}

//enable the loop above
//It only works with "i" for index
//while_loop_fn();


//  #########################################################
//  ### End of loop emulation                             ###
//  #########################################################



//a way to enable and disable log everywhere
LOG = function(a){
    //log(a);
}

//define a popup handler
alert = function(msg) {
        var app = [NSApplication sharedApplication];
        [app displayDialog:msg];
    }
//pass a string and it will replace shash with dot everywhere
//then return back that string
replace_slash = function(input){
    if(input.indexOf("/")>-1){
    input = input.toString().replace("/", ".");
    return replace_slash(input)
    }else{
    return input
    }
}

//function to check if item is the end of a branch of an object {}
end = function(item){
    for(var someotherkey in item){
        if(typeof item != "string" && typeof item != "number"){return false}
    };
    return true;
}

//build json, it needs: 
//the obj which is the json
//path in the shape of xxx.yyy.zzz
//value to assign to that path
JSONbuilder = function(obj, path, value){ LOG("BUILDER_PATH: "+path); LOG("BUILDER_VALUE: "+value);
    var pointer = obj;
    var path = path.split(".");
    //log(path)
    for(var i=0; i<path.length; i++){
    if(typeof pointer[path[i]+""] == "undefined"&&i<path.length-1){
        pointer[path[i]+""]={}; pointer = pointer[path[i]+""];
    }else if(typeof pointer[path[i]+""] == "undefined" || typeof pointer[path[i]+""] == "string" || typeof pointer[path[i]+""] == "number"){
        LOG("change it with: "+value)
        pointer[path[i]+""]=value+"";
    }else{
        pointer = pointer[path[i]+""];
    };
    }
    return {"obj":obj,"pointer":pointer};
}

//iterate a symbol overridePoints
//find out what's their current value at each point
//build that into a json JSONbuilder
buildSymbolView = function(array,json_view){
    if(array==null){return}
    if(json_view==undefined){var json_view = {}}
    for(var i = 0; i < array.length; i++){
        var block = array[i].overridePoint().toString().split("_");
        if(block[1]=="stringValue"){
        //log("STRING")
        LOG(block[0]+" : "+array[i].currentValue());
        var path = replace_slash(block[0])
        JSONbuilder(json_view,path,array[i].currentValue().toString())
        }else if(block[1]=="image"){
        LOG(block[0]+" : "+array[i].currentValue());
        var path = replace_slash(block[0])
        JSONbuilder(json_view,path,array[i].currentValue().toString())
        }else if(block[1]=="symbolID"){
        //log("SYMBOL")
        LOG(block[0]+" : {symbolID:"+array[i].currentValue()+"}")
        var path = replace_slash(block[0])
        JSONbuilder(json_view,path+".symbolID",array[i].currentValue().toString())
        buildSymbolView(array[i].internalChildren(),json_view)
        }
    }
    return json_view
}


//find all the layers in the current page that match the given value, maybe use selection
findSameValueTextLayer_text = function(text,selection){
    var list = [];
    var a = text;
    var selection = selection || children;
    for(var i=0; i<selection.length; i++){
        if(selection[i].className().isEqualToString('MSTextLayer')){
            //LOG(children[i].className()+" and "+children[i].stringValue()+"; Also "+text.className()+" and "+text.stringValue());
            var b = ""+selection[i].stringValue();
            if(a == b || a == "***"){LOG("true");
                list.push(selection[i]);
            };
        }
    };
    return list;
}

//find all the layers in the current page that HAVE the given value, maybe use selection
findTextLayer_approxText = function(text,selection){
    var list = [];
    var a = text;
    var selection = selection || children;
    for(var i=0; i<selection.length; i++){
        if(selection[i].className().isEqualToString('MSTextLayer')){
            //LOG(children[i].className()+" and "+children[i].stringValue()+"; Also "+text.className()+" and "+text.stringValue());
            var b = ""+selection[i].stringValue();
            if(b.indexOf(a)>=0){LOG("true");
                list.push(selection[i]);
            };
        }
    };
    return list;
}

//find all the layers in the current page that are text
findTextLayers = function(){
    var list = [];
    for(var i=0; i<children.length; i++){
        if(children[i].className().isEqualToString('MSTextLayer')){
                list.push(children[i]);
        }
    };
    return list;
}


//find all the layers in the current page that are key/value
findSameValueTextLayer = function(layer){
    var text = ""+layer.stringValue();
    findSameValueTextLayer_text(text);
    return list;
}

//pass a list of text layers and apply the value
applyNewValueToTextLayers = function(text_layers){
    if(text_layers == undefined){alert("applyNewValueToTextLayers had an undefined parameter passed to it"); return}
    for (var key in text_layers){
        findById(key+"").setStringValue(text_layers[key])
    }
}


//overrideSymbol2
overrideSymbolByPath = function(symbol,key,value,action){

    var prop = {}

    var overrides = buildSymbolView(symbol.availableOverrides())

    //-------


    function builderz(obj, path, value){ LOG("BUILDER: "+path);
    var pointer = obj;
    var path = path.split(".");
    for(var i=0; i<path.length-1; i++){
    if(typeof pointer[path[i]+""] == "undefined"&&i<path.length-2){
        pointer[path[i]+""]={}; pointer = pointer[path[i]+""];
    }else if(typeof pointer[path[i]+""] == "undefined" || typeof pointer[path[i]+""] == "string" || typeof pointer[path[i]+""] == "number"){
        LOG("change it with: "+value)
        pointer[path[i]+""]=value+"";
    }else{
        pointer = pointer[path[i]+""];
    };
    }
    return {"obj":obj,"pointer":pointer};
    }

    function iterateOverrides(prop,overrides,exception,path){
    if(typeof path == 'undefined'){var path=""};
    for(var KEY in overrides){//LOG("Exception: "+exception+" KEY: "+KEY); 
        path+=KEY+".";
            if(""+path == exception+""){LOG("Found matching Path: "+path)}
            if(!path.indexOf(""+exception)==0){
                LOG("KEY="+KEY); 
                //end(overrides[""+KEY]);
                if(end(overrides[KEY])){
                    if(""+exception!=path+""){
                        var temp_prop = builderz(prop, path, overrides[""+KEY]);
                    }
                }else{
                    iterateOverrides(prop,overrides[""+KEY],exception,path);
                }
            }
        path = path.split(KEY+".")[0]
    }
    };

    //-------

    iterateOverrides(prop,overrides); 
    LOG("The final PROP is"); LOG(prop);

    if(action=="delete"){LOG("DELETE ACTION");
    PROP = {};
    iterateOverrides(PROP,prop,key);
    prop = PROP;
    }else if(action=="get"){LOG("GET ACTION");


    }else{LOG("EDIT ACTION");
    PROP = prop;
    builderz(PROP,key,value);
    prop = PROP;
    };

    LOG("Proccessed prop =")
    LOG(prop);
    symbol.setOverrides(prop);
}


//find layer by ID
findById = function(id){
    var ID = context.document.documentData().symbolWithID(id) || context.document.documentData().layerWithID(id)
    if(ID){return ID};
    LOG("+++CONTINUING");
    for(var page_number=0; page_number<context.document.pages().length; page_number++){
        //LOG(context.document.pages()[page_number])
        for(var child_number=0; child_number<context.document.pages()[page_number].children().length; child_number++){
            //LOG(context.document.pages()[page_number].children()[child_number])
            if(context.document.pages()[page_number].children()[child_number].objectID()+""==id+""){
                //LOG("## LAYER FOUND ###"+context.document.pages()[page_number]+"#####");
                return context.document.pages()[page_number].children()[child_number]
            }
        }
    };
    for(var page_number=0; page_number<context.document.pages().length; page_number++){
        //LOG(context.document.pages()[page_number])
        for(var child_number=0; child_number<context.document.pages()[page_number].artboards().length; child_number++){
            //LOG(context.document.pages()[page_number].artboards()[child_number])
            if(context.document.pages()[page_number].artboards()[child_number].objectID()+""==id+""){
                //LOG("## ARTBOARD FOUND ###"+context.document.pages()[page_number]+"#####");
                return context.document.pages()[page_number].artboards()[child_number]
            }
        }
    }
}
//*/


//delete key
deleteKey = function(symbol,key){overrideSymbolByPath(symbol,key,"_","delete");}
editKey = function(symbol,key,value){overrideSymbolByPath(symbol,key,value);}

iterateSymbolsAndDoSomething = function(select,fn){
    for(var i = 0; i < select.length; i++){
        if(select[i].className().isEqualToString('MSSymbolInstance')){
            LOG("Iterate"+select[i])
            fn(select[i]);
        };
    }
}

currentSelection = function(){
    var currentChildren = []
    for (var i = selection.length - 1; i >= 0; i--) {
        var selected = selection[i];
        if(selected.className().isEqualToString('MSLayerGroup')||selected.className().isEqualToString('MSArtboardGroup')){
            var groupChildren = selected.children();
            for (var ii = groupChildren.length - 1; ii >= 0; ii--) {
                currentChildren.push(groupChildren[ii]);
            };
        }else{
            currentChildren.push(selected);
        }
    };
    return currentChildren
}

jsonSymbolsInSelection = function(){
    var currentChildren = currentSelection();
    iterateSymbolsAndDoSomething(currentChildren,buildjson_json);
}

jsonSymbolsInCurrentPage = function(){
    var currentChildren = document.currentPage().children();
    iterateSymbolsAndDoSomething(currentChildren,buildjson_json);
}

buildjson_json = function(symbol){
    json = buildjson(symbol,json)
}

buildjson = function(symbol,json){
    if(typeof json == "undefined"){var json = {};};
    json[symbol.objectID()+""]=buildSymbolView(symbol.availableOverrides());
    return json;
}

matchFromJson = function(jsonImported){
    for(var layer in jsonImported){
        _layer = findById(layer+"");
        if(typeof _layer != "undefined" && _layer!="undefined" && _layer.className().isEqualToString('MSSymbolInstance')){
            _layer.setOverrides(jsonImported[layer]);
        }
    }
}



saveToJson = function(){

    json = {};

    jsonSymbolsInCurrentPage();

    var text_layers = findTextLayers();
    var json_text_layers = {}
    for (var i = text_layers.length - 1; i >= 0; i--) {
        json_text_layers[text_layers[i].objectID()] = text_layers[i].stringValue()+"";
    };

    var combined_json = {};
    combined_json.symbols = json;
    combined_json.text_layers = json_text_layers;

    LOG("*****SHOW combined_json*****")
    LOG(combined_json);

    var save = NSSavePanel.savePanel();
        save.setNameFieldStringValue("untitled.json");
        save.setAllowedFileTypes(["json"]);
        save.setAllowsOtherFileTypes(false);
        save.setExtensionHidden(false);

    if (save.runModal()) {
        var filePath = save.URL().path();
        var file = NSString.stringWithString(JSON.stringify(combined_json));
            
        //file.writeToFile_atomically_encoding_error(filePath, true, NSUTF8StringEncoding, null);
        saveJsonToFile(combined_json, filePath)

    }   
}

stringify = function(obj, prettyPrinted) {
    var prettySetting = prettyPrinted ? NSJSONWritingPrettyPrinted : 0,
    jsonData = [NSJSONSerialization dataWithJSONObject:obj options:prettySetting error:nil];
    return [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
}

writeTextToFile = function(text, filePath) {
    var t = [NSString stringWithFormat:@"%@", text],
    f = [NSString stringWithFormat:@"%@", filePath];
    return [t writeToFile:f atomically:true encoding:NSUTF8StringEncoding error:nil];
}

readTextFromFile = function(filePath) {
    var fileManager = [NSFileManager defaultManager];
    if([fileManager fileExistsAtPath:filePath]) {
        return [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];
    }
    return nil;
}

jsonFromFile = function(filePath, mutable) {
    var data = [NSData dataWithContentsOfFile:filePath];
    var options = mutable == true ? NSJSONReadingMutableContainers : 0
    return [NSJSONSerialization JSONObjectWithData:data options:options error:nil];
}

saveJsonToFile = function(jsonObj, filePath) {
    writeTextToFile(stringify(jsonObj), filePath);
}


loadFromJson = function(){
    json = {};
    text_layers = {};
    var app = NSApp.delegate();
    var doc = context.document;
    //var version = context.plugin.version().UTF8String();
    var fileTypes = ["json"];
        
    // Open file picker to choose palette file
    var open = NSOpenPanel.openPanel();
    open.setAllowedFileTypes(fileTypes);
    open.setCanChooseDirectories(true);
    open.setCanChooseFiles(true);
    open.setCanCreateDirectories(true);
    open.setTitle("Choose a file");
    open.setPrompt("Choose");
    open.runModal();
    
    // Read contents of file into NSString, then to JSON
    var filePath = open.URLs().firstObject().path();
    var fileContents = NSString.stringWithContentsOfFile(filePath);

    combined_json = jsonFromFile(filePath, true)

    //combined_json = JSON.parse(fileContents.toString());

    LOG(combined_json);

    if(typeof combined_json.symbols != "undefined"){
        json = combined_json.symbols;
    }

    if(typeof combined_json.text_layers != "undefined"){
        text_layers = combined_json.text_layers;
    }

    //only text layers
    applyNewValueToTextLayers(text_layers);

    //only for symbols
    matchFromJson(json);
}

//convert json output from buildjson_json(context.selection[0]) to human readable
convert_json_to_human = function(obj){
    var temp_obj = {};
    for (var key in obj){
        var value = obj[key];
        if(typeof value == 'object'){
            temp_obj[findById(key).name()+"___"+key+""] = convert_json_to_human(value);
        }else if(key == "symbolID"){
            temp_obj["symbolID"] = value
        }else if(key.length > 30 ){
            temp_obj[findById(key).name()+"____"+key] = value
        }
    }
    return temp_obj;
}



look_deeper_list =[]

look_deeper = function(obj,exact_text,path){ 
    if(typeof path == "undefined"){var path = ""}; 
    if(typeof obj == "undefined"){return "obj is not defined"};
    if(typeof exact_text == "undefined"){return "exact_text is not defined"};
    for(var key in obj){log(key)
        var value = obj[key];
        if(typeof value == "string"){
            log("****START*****");log(value);log("****END*****");
            if(value == exact_text){
                log("===>FOUND");
                look_deeper_list.push(path+"."+key)
            }else if(exact_text == "***" && value.toString() != "symbolID" && !(value.toString().split("-")[0].length == 8 && value.toString().split("-")[1].length == 4 && value.toString().split("-")[2].length == 4 && value.toString().split("-")[3].length == 4 && value.toString().split("-")[4].length == 12) ){
                log("===>JOLLY");
                look_deeper_list.push(path+"."+key)
            }
        }else if(typeof value == "object"){
            look_deeper(value,exact_text,path+"."+key);
        }
    }
}

look_deeper_approx = function(obj,approx_text,path){ 
    if(typeof path == "undefined"){var path = ""}; 
    if(typeof obj == "undefined"){return "obj is not defined"};
    if(typeof approx_text == "undefined"){return "exact_text is not defined"};
    for(var key in obj){LOG(key)
        var value = obj[key];
        if(typeof value == "string"){
            if(value.indexOf(approx_text)>=0){
                look_deeper_list.push(path+"."+key)
            }
        }else if(typeof value == "object"){
            look_deeper_approx(value,approx_text,path+"."+key);
        }
    }
}

getValue = function(obj,pathToValue,path,valueToReturn){ 
    if(typeof path == "undefined"){var path = ""}; 
    if(typeof obj == "undefined"){return "obj is not defined"};
    if(typeof pathToValue == "undefined"){return "pathToValue is not defined"};
    if(typeof valueToReturn == "undefined"){var valueToReturn = "none";};
    for(var key in obj){LOG(key)
        var value = obj[key];
        if(path+"."+key==pathToValue||path+"."+key=="."+pathToValue){
            LOG("*****Found the path is \""+path+"."+key+"\"*****");
            return value;
        }
        if(typeof value == "string"){
            LOG("Current path is \""+path+"."+key+"\"");
            //return "The value is "+value;
        }else if(typeof value == "object"){
            LOG("Current path is \""+path+"."+key+"\"");
            valueToReturn = getValue(value,pathToValue,path+"."+key,valueToReturn);
        }
    };
    if(valueToReturn){return valueToReturn};
}

//helper for dialog
getAlertWindow = function() {
    var alert = COSAlertWindow.new();
    return alert;
}

fakeFunc = function() {
    og("Fake func");
}

//define a dialog
newAlert = function(title){
    var settingsWindow = getAlertWindow();
    settingsWindow.setMessageText((title)?title:"Title");
    return settingsWindow
}

fnCheck = function(fn){
    if(typeof fn == 'undefined'){
        return false;
    }
    return true;
}

//add a button to dialog
addButton = function(alert,string,fn){
    return alert.addButtonWithTitle((string)?string:"Ok");
}

//add radial to dialog
addRadial = function(alert,string,fn){
    var pageButton = NSButton.alloc().initWithFrame(NSMakeRect(0,0,300,22));
    pageButton.setTitle((string)?string:"Label");
    pageButton.setButtonType(NSRadioButton);
    pageButton.setAction(fn);
    alert.addAccessoryView(pageButton);
    return pageButton;
}

//add checkbox to dialog
addCheckBox = function(alert,string,fn){
    var showsWarningCheckbox = NSButton.alloc().initWithFrame(NSMakeRect(0,0,300,22));
        showsWarningCheckbox.setButtonType(NSSwitchButton);
        showsWarningCheckbox.setBezelStyle(0);
        showsWarningCheckbox.setTitle((string)?string:"Label");
        showsWarningCheckbox.setState(NSOffState);
        alert.addAccessoryView(showsWarningCheckbox);
        return showsWarningCheckbox;
}

//call dialog
runAlert = function(alert){
    return alert.runModal();
}

addText = function(alert,string,fn){
    if(fnCheck(fn) && fn.indexOf("w=")>-1){
        w = fn.split("w=")[1].split(",")[0];
    }else{
        w = 210;
    };
    if(fnCheck(fn) && fn.indexOf("h=")>-1){
        h = fn.split("h=")[1].split(",")[0];
    }else{
        h = 20;
    };
    if(fnCheck(fn) && fn.indexOf("fontSize=")>-1){
        fontSize = fn.split("fontSize=")[1].split(",")[0];
    }else{
        fontSize = 12;
    };
    var inputRowCountLabel = NSTextField.alloc().initWithFrame(NSMakeRect(0,58,w,h))
    inputRowCountLabel.setStringValue(string)
    [inputRowCountLabel setDrawsBackground:false];
    [inputRowCountLabel setEditable:false];
    [inputRowCountLabel setSelectable:false];
    [inputRowCountLabel setBezeled:false];
    [inputRowCountLabel setFont:[NSFont systemFontOfSize:fontSize]]];
    alert.addAccessoryView(inputRowCountLabel);
    return inputRowCountLabel;
}


addInputField = function(alert,string,fn){
    var inputRowCountLabel = NSTextField.alloc().initWithFrame(NSMakeRect(0,58,210,20))
    inputRowCountLabel.setStringValue(string)
    [inputRowCountLabel setDrawsBackground:false];
    [inputRowCountLabel setEditable:true];
    //[inputRowCountLabel setSelectable:false];
    //[inputRowCountLabel setBezeled:false];
    //[inputRowCountLabel setFont:[NSFont systemFontOfSize:10]]]
    alert.addAccessoryView(inputRowCountLabel);
    return inputRowCountLabel;
}


selectOptions = ['Option1', 'Option2'];

addDropDownMenu = function(alert,string,fn){
    var orderSelect = NSComboBox.alloc().initWithFrame(NSMakeRect(0,0,268,28))
    orderSelect.addItemsWithObjectValues(selectOptions)
    orderSelect.selectItemAtIndex(0);
    [orderSelect setEditable:false];
    alert.addAccessoryView(orderSelect);
}

//fake function
fn = function(){LOG("log")}



}
//########################################################
//########################################################

var exportToJSON = function(context){
    initiate(context);
    saveToJson();
}


var loadFromJSON = function(context){
    initiate(context);
    loadFromJson();
}


var findAndReplaceEvery = function(context){
    initiate(context);

    //
myModal = newAlert("Find & Replace");
addText(myModal,"What do you want to find?");
var exact_text = addInputField(myModal,"Type what to find here");
var strict = addCheckBox(myModal,"Use strict mode");
addText(myModal," ");
addText(myModal,"How to replace?");
var substitute_text = addInputField(myModal,"Type how to replace here");
addText(myModal," ");
addText(myModal,"NB. Strict mode will only match the whole string of a text. It won't find text within a string.","h=60,fontSize=10");
var applyEverywhere = addCheckBox(myModal,"Skip find, just replace!");
var highlight = addCheckBox(myModal,"Highlight changes?");
var ok = addButton(myModal,"Ok");
var cancel = addButton(myModal,"Cancel");
//Enable to run modal
runAlert(myModal);
//*/

substitute_text = substitute_text.stringValue();
exact_text = exact_text.stringValue();
strict = parseInt(strict.stringValue());
applyEverywhere = parseInt(applyEverywhere.stringValue());
highlight = parseInt(highlight.stringValue());
ok = parseInt(ok.stringValue());
cancel = parseInt(cancel.stringValue());

if(ok&&!cancel){
    log('OK was pressed')

//
//clear selection, not sure why
//if(context.selection.length > 0){context.selection[0].select_byExpandingSelection(false, false);}

//ask user what text they want to find with a dialog
//var exact_text = [document askForUserInput:'What do you want to find?' initialValue:'exact text here'];



//make a list of layers 
if(context.selection.length > 0 && applyEverywhere){
        var list = findSameValueTextLayer_text("***",currentSelection());
}else if(context.selection.length > 0){
    switch(strict){
        case 0:
        var list = findTextLayer_approxText(exact_text,currentSelection());
        break;
        case 1:
        var list = findSameValueTextLayer_text(exact_text,currentSelection());
        break;
        default:
        var list = findTextLayer_approxText(exact_text,currentSelection());
    }
}else{
    switch(strict){
        case 0:
        var list = findTextLayer_approxText(exact_text);
        break;
        case 1:
        var list = findSameValueTextLayer_text(exact_text);
        break;
        default:
        var list = findTextLayer_approxText(exact_text);
    }
}


LOG(list)

json = {};
if(context.selection.length > 0 && applyEverywhere){

        jsonSymbolsInSelection();
        look_deeper(json,"***");
        strict = 1;

    }else if(context.selection.length > 0){
        jsonSymbolsInSelection();

        switch(strict){
        case 0:
        look_deeper_approx(json,exact_text)
        break;
        case 1:
        look_deeper(json,exact_text)
        break;
        default:
        look_deeper_approx(json,exact_text)
        }

    }else{
        jsonSymbolsInCurrentPage();

        switch(strict){
        case 0:
        look_deeper_approx(json,exact_text)
        break;
        case 1:
        look_deeper(json,exact_text)
        break;
        default:
        look_deeper_approx(json,exact_text)
        }
    }
    


//if nothing returns alert the user
if(list.length < 1 && look_deeper_list.length < 1){alert("No layer found with text: "+exact_text)}else{
    //ask user what text they want to change it with
    //var substitute_text = [document askForUserInput:'How do you want to change it?' initialValue:'exact text here'];

    //apply new value to Text layers
    for (var i = 0; i < list.length; i++) {
        //list[i].select_byExpandingSelection(true, true);
        switch(strict){
            case 0:
            list[i].setStringValue(list[i].stringValue().replace(exact_text, substitute_text));
            break;
            case 1:
            list[i].setStringValue(substitute_text);
            break;
            default:
            list[i].setStringValue(list[i].stringValue().replace(exact_text, substitute_text));
        }
        addObjectForShape(list[i]);
    }  

    //this part is for symbols
    //json = {};
    //if(context.selection.length > 0){jsonSymbolsInSelection()}else{jsonSymbolsInCurrentPage()}

    LOG(json)

    //look_deeper(json,exact_text)

    log('##### Show List ######')

    log(look_deeper_list)

    //edit key with this new value for symbols edit(symbol,key_path,new_value)
    for (var i = look_deeper_list.length - 1; i >= 0; i--) {
        var remove_dot = look_deeper_list[i].slice(1)
        var entity_id = remove_dot.split(".")[0]
        var path_to_edit = remove_dot.slice(remove_dot.indexOf(".")+1)+"."
        LOG("the value for \""+path_to_edit+"\" is \""+getValue(json,remove_dot)+"\"");
        switch(strict){
            case 0:
            editKey(findById(entity_id),path_to_edit,getValue(json,remove_dot).replace(exact_text, substitute_text));
            break;
            case 1:
            editKey(findById(entity_id),path_to_edit,substitute_text);
            break;
            default:
            editKey(findById(entity_id),path_to_edit,getValue(json,remove_dot).replace(exact_text, substitute_text));
        }
        addObjectForShape(findById(entity_id))
    };

    if(highlight){process_addObjectForShapeArray();}


}



//*/

}else{
    log('Cancel was pressed')
}

}


//#######################################################
//#######################################################

var selectSameSymbolInstances = function(context) {

var document = context.document
var artboards = document.artboards()
var pages = document.pages()

var alert= function(msg) {
        var app = [NSApplication sharedApplication];
        [app displayDialog:msg];
    }

//make a list of all the layers from the current page
var children = document.currentPage().children();
//for(var i=0; i<pages.length; i++){for(var n=0;n<pages[i].children().length;n++){children.push(pages[i].children()[n])}}

//find all the layers in the current page that are from the same symbol instance
function findSameMasterInstanceLayers(layer){
var list = [];
for(var i=0; i<children.length; i++){if(children[i].className().isEqualToString('MSSymbolInstance')&&children[i].symbolMaster().objectID() == layer.symbolMaster().objectID()){list.push(children[i])}};
return list;
}

//call function with selected element
if(context.selection.length==1&&context.selection[0].className().isEqualToString('MSSymbolInstance')){
var list = findSameMasterInstanceLayers(context.selection[0])
//make new selection
for (var i = 0; i < list.length; i++) {
    list[i].select_byExpandingSelection(true, true);
}
}else if(context.selection.length==1){
alert("You have selected a "+context.selection[0].className()+"! you need to select a symbol.")
}else if(context.selection.length==0){
alert("No layer selected! Select a symbol.")
}else if(context.selection.length>1){
alert("Too many layers selected! Select 1 symbol.")
}else{
alert("Error but I dont know")
}


}


//#######################################################
//#######################################################

var sameValueTextLayers = function(context) {

var document = context.document
var artboards = document.artboards()
var pages = document.pages()

var alert= function(msg) {
        var app = [NSApplication sharedApplication];
        [app displayDialog:msg];
    }

//make a list of all the layers from the current page
var children = document.currentPage().children();
//for(var i=0; i<pages.length; i++){for(var n=0;n<pages[i].children().length;n++){children.push(pages[i].children()[n])}}

//find all the layers in the current page that are key/value
function findSameValueTextLayer (layer){
var list = [];
for(var i=0; i<children.length; i++){
    if(children[i].className().isEqualToString('MSTextLayer')){
        //log(children[i].className()+" and "+children[i].stringValue()+"; Also "+layer.className()+" and "+layer.stringValue());
        var a = ""+layer.stringValue(); 
        var b = ""+children[i].stringValue();
        if(a == b){
            list.push(children[i]);
        };
    }
};
return list;
}

//call function with selected element
if(context.selection.length==1&&context.selection[0].className().isEqualToString('MSTextLayer')){
var list = findSameValueTextLayer(context.selection[0]);
//make new selection
for (var i = 0; i < list.length; i++) {
    list[i].select_byExpandingSelection(true, true);
}
}else if(context.selection.length==1){
alert("You have selected a "+context.selection[0].className()+"! you need to select a text layer.")
}else if(context.selection.length==0){
alert("No layer selected! Select a text.")
}else if(context.selection.length>1){
alert("Too many layers selected! Select 1 text.")
}else{
alert("Error but I dont know")
}

}


//#######################################################
//#######################################################

var onReadyToExport = function(context) {

var document = context.document;
var selection = context.selection;
var obj = 0;
var masters = [];

initiate(context);

var myalert = newAlert("Make sure you duplicate this document before!")
addButton(myalert,"Go",fn)
addButton(myalert,"Cancel",fn)
//addRadial(myalert,"Options",fn)
//checkbox = addCheckBox(myalert,"Remove export options from Symbol",fn)



addSlice = function(where){
var slice = MSSliceLayer.alloc().initWithFrame_(NSMakeRect(0, 0, where.rect().size.width, where.rect().size.height));
slice.setName(where.name());
where.addLayers_([slice]);
slice.exportOptions().setLayerOptions(2);
slice.exportOptions().setExportFormats(where.exportOptions().exportFormats());

/*if(checkbox.state() == 0 ? 0 : 1){
where.exportOptions().setExportFormats([]);
}*/

}

var runThis = function(){

    //detach all the instances from library
    loopUnlink();

//log(document.pages()[1].children())
for(var i=0; i < document.pages().count(); i++){
if(document.pages()[i].name() == "Symbols"){
var symbolPage = document.pages()[i];
for(var j=0; j < symbolPage.children().count(); j++){
if(symbolPage.children()[j].class() == "MSSymbolMaster"){
masters.push(symbolPage.children()[j]);
}
}
}
}

var number = 0

for(var i = 0; i < masters.length; i++){
if(masters[i].exportOptions().exportFormats().count() > 0){
    moveSelectionToGroup(masters[i].layers());
    addSlice(masters[i]);
    number+=1;
}
}

//select all the instances
var myElement = selectAllInstanes();

//Break recursivelly all the instances
breakAllSymbols(myElement);

number = number+" slices added!"



alert( (i==0)?"Done : ":number )
}

response = (1001-runAlert(myalert)>0)?true:false

if(response){
    runThis();
}

};

//#######################################################
//#######################################################

var onAddSlicesAnima = function(context) {

var document = context.document;
var selection = context.selection;
var obj = 0;
var masters = [];

initiate(context);

var myalert = newAlert("Add Slices before export")
addButton(myalert,"Go",fn)
addButton(myalert,"Cancel",fn)
//addRadial(myalert,"Options",fn)
checkbox = addCheckBox(myalert,"Remove export options from Symbol",fn)



addSlice = function(where){
var slice = MSSliceLayer.alloc().initWithFrame_(NSMakeRect(0, 0, where.rect().size.width, where.rect().size.height));
slice.setName(where.name());
where.addLayers_([slice]);
slice.exportOptions().setLayerOptions(2);
slice.exportOptions().setExportFormats(where.exportOptions().exportFormats());

if(checkbox.state() == 0 ? 0 : 1){
where.exportOptions().setExportFormats([]);
}

}

var runThis = function(){

//log(document.pages()[1].children())
for(var i=0; i < document.pages().count(); i++){
if(document.pages()[i].name() == "Symbols"){
var symbolPage = document.pages()[i];
for(var j=0; j < symbolPage.children().count(); j++){
if(symbolPage.children()[j].class() == "MSSymbolMaster"){
masters.push(symbolPage.children()[j]);
}
}
}
}

var number = 0

for(var i = 0; i < masters.length; i++){
if(masters[i].exportOptions().exportFormats().count() > 0){
    moveSelectionToGroup(masters[i].layers());
    addSlice(masters[i]);
    number+=1;
}
}

number = number+" slices added!"



alert( (i==0)?"No slices added":number )
}

response = (1001-runAlert(myalert)>0)?true:false

if(response){
    runThis();
}

};

//#########################################################
//#########################################################

var onAutoRenamerIncremental = function(context) {

var names = [];
var changes = 0;
var fragment = [];
var count = 0;
var document = context.document;
var alert= function(msg) {
        var app = [NSApplication sharedApplication];
        [app displayDialog:msg];
    }

stop = function(really){
    (really)?log('stop!!!!'):log('OK!')
    stop = !really; 
}

start = function(){
var fullName = [document askForUserInput:'Insert common name' initialValue:'FRAME '];
for(var i = context.selection.count()-1; i >= 0; i--){
    I=context.selection.count()-i-1;
    //fullName = (I<10)?fullName+"0"+(I)+"":fullName+(I);
    context.selection[i].setName((I<10)?fullName+"0"+(I)+"":fullName+(I));
}

alert( "Changes Done!" )

}

for(var i = 0; i < context.selection.count(); i++){
names.push(context.selection[i].name());
}

start();

};

//#########################################################
//#########################################################

var onAutoRenamerSamer = function(context) {

var names = [];
var changes = 0;
var fragment = [];
var count = 0;
var document = context.document;
var alert= function(msg) {
        var app = [NSApplication sharedApplication];
        [app displayDialog:msg];
    }

stop = function(really){
    (really)?log('stop!!!!'):log('OK!')
    stop = !really; 
}

start = function(){
log('start!');
var fullName = [document askForUserInput:'Insert common name' initialValue:'Name'];
if(fullName){
for(var i = context.selection.count()-1; i >= 0; i--){
    I=context.selection.count()-i-1;
    context.selection[i].setName(fullName);
}

alert( "Changes Done!" );

}else{
    alert( "No name was given!" );
}

}

for(var i = 0; i < context.selection.count(); i++){
log(context.selection[i].name());
names.push(context.selection[i].name());
}

start();

log(fullName);

};

//#########################################################
//#########################################################

var onAutoRenamerSubstituter = function(context) {
  var names = [];
var changes = 0;
var fragment = [];
var count = 0;
var document = context.document;
var string = [document askForUserInput:'WHAT to replace' initialValue:''];
var replacement = [document askForUserInput:'HOW to replace' initialValue:string];
var alert= function(msg) {
        var app = [NSApplication sharedApplication];
        [app displayDialog:msg];
    }

stop = function(really){
    (really)?log('stop!!!!'):log('OK!')
    stop = !really; 
}

start = function(){
log('start!');
for(var i = 0; i < context.selection.count(); i++){
    var fullName = context.selection[i].name();
    if(fullName.indexOf(string)>-1){
        changes+=1;
        fullName = fullName.split(string)[0] + replacement + fullName.split(string)[1];
        context.selection[i].setName(fullName);
    }else{
        //alert('String: \"'+string+'\" could not be found in: \"'+ context.selection[i].name()+'\"');
    }
}

alert( (changes) + " changes were made out of " + (context.selection.count()))

}

for(var i = 0; i < context.selection.count(); i++){
log(context.selection[i].name());
names.push(context.selection[i].name());
}

start();

}

//#########################################################
//#########################################################

var onAutoRenamerAppender = function(context) {
  var names = [];
var changes = 0;
var fragment = [];
var count = 0;
var document = context.document;
var string = [document askForUserInput:'WHAT to append' initialValue:''];
var alert= function(msg) {
        var app = [NSApplication sharedApplication];
        [app displayDialog:msg];
    }

stop = function(really){
    (really)?log('stop!!!!'):log('OK!')
    stop = !really; 
}

start = function(){
log('start!');
for(var i = 0; i < context.selection.count(); i++){
    var fullName = context.selection[i].name();
        changes+=1;
        fullName = fullName + string;
        context.selection[i].setName(fullName);
}

alert( (changes) + " changes were made out of " + (context.selection.count()))

}

for(var i = 0; i < context.selection.count(); i++){
log(context.selection[i].name());
names.push(context.selection[i].name());
}

if(string){
start();
}else{
    alert('No name provided');
}

};

//#########################################################
//#########################################################

var onAddPrefix = function(context) {
  var names = [];
var changes = 0;
var fragment = [];
var count = 0;
var document = context.document;
var string = [document askForUserInput:'WHAT to append' initialValue:''];
var alert= function(msg) {
        var app = [NSApplication sharedApplication];
        [app displayDialog:msg];
    }

stop = function(really){
    (really)?log('stop!!!!'):log('OK!')
    stop = !really; 
}

start = function(){
log('start!');
for(var i = 0; i < context.selection.count(); i++){
    var fullName = context.selection[i].name();
        changes+=1;
        fullName = string + fullName;
        context.selection[i].setName(fullName);
}

alert( (changes) + " changes were made out of " + (context.selection.count()))

}

for(var i = 0; i < context.selection.count(); i++){
log(context.selection[i].name());
names.push(context.selection[i].name());
}

if(string){
start();
}else{
    alert('No name provided');
}

};

//#########################################################
//#########################################################

var onRunWhite = function(context,color) {onRunSwapColor(context,'white');
}

var onRunBlack = function(context,color) {onRunSwapColor(context,'black');
}

var onRunCustom = function(context,color) {onRunSwapColor(context,'custom');
}

var onRunSwapColor = function(context,color) {
  
var doc = context.document;
var page = [doc currentPage];
var shape = page.layers().objectAtIndex(0)

var palette = {
    black : '#000000', //black
    white : '#ffffff' //white
};

var fillWhite = function(c) {
    colorFill(c, palette.white);
};
var fillBlack = function(c) {
    colorFill(c, palette.black);
};

var borderWhite = function(c) {
    colorBorder(c, palette.white);
};
var borderBlack = function(c) {
    colorBorder(c, palette.black);
};

var fillCustom = function(c) {
    colorFill(c, palette.custom);
};

var borderCustom = function(c) {
    colorBorder(c, palette.custom);
};


function hexToRgba(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

        if (result) {
            result = {
                r : parseInt(result[1], 16)/255,
                g : parseInt(result[2], 16)/255,
                b : parseInt(result[3], 16)/255,
                a : 1
            };
        } else {
            result = null;
        }

        return result;
}


function colorBorder(cont,color){
   var selection = cont.selection;

    //iterate layers
    for(var i=0; i<selection.count(); i++){
        var layer = selection[i];

        if (layer.class() === MSShapeGroup) {
           var layer = selection[i];  
           var styles = layer.style();
           var border = styles.borders().firstObject();
           if(border!=null){border.color = MSColor.colorWithRed_green_blue_alpha(hexToRgba(color).r, hexToRgba(color).g, hexToRgba(color).b, hexToRgba(color).a)};
        }
    }
}

function colorFill(cont,color){
    var selection = cont.selection;
    
    //iterate layers
    for(var i=0; i<selection.count(); i++){
        var layer = selection[i];

        if (layer.class() === MSTextLayer) {
            layer.textColor = MSColor.colorWithRed_green_blue_alpha(hexToRgba(color).r, hexToRgba(color).g, hexToRgba(color).b, hexToRgba(color).a);
        }
        if (layer.class() === MSShapeGroup) {

            //get layer style
            var shapeStyle = layer.style();

            //get layer style fills array
            var fills = shapeStyle.fills();
            
            var fill = null;
            if(fills.count() > 0 ){ 
                //get first fill layer style
                fill = fills.firstObject();
            }

            
            //set color to first fill layer style
            
            if(fill!=null){fill.color = MSColor.colorWithRed_green_blue_alpha(hexToRgba(color).r, hexToRgba(color).g, hexToRgba(color).b, hexToRgba(color).a)};

            log(fills.firstObject());
       }
    }
}

function black(context){
    fillBlack(context); 
    borderBlack(context);
}

function white(context){
    fillWhite(context); 
    borderWhite(context);
}

function custom(context){
    palette.custom = [doc askForUserInput:'Enter a prefix #color' initialValue:'#ffffff'];
    fillCustom(context); 
    borderCustom(context);
}


switch(color) {
    case 'white':
        white(context)
        break;
    case 'black':
        black(context)
        break;
    default:
        custom(context)
} 

};
